from telethon import TelegramClient, events
import asyncio
import os
import time
import re
import json
from datetime import datetime
from instagrapi import Client
from instagrapi.exceptions import ClientError, ClientLoginRequired
import random
import logging
import sys
import select
import collections

# ================= FICHIER DE CONFIGURATION EXTERNE =================
CONFIG_FILE = "smm_config_second.json"  # Fichier diffÃ©rent pour Ã©viter conflit

def load_config():
    """Charge la configuration depuis un fichier JSON externe"""
    if not os.path.exists(CONFIG_FILE):
        # Configuration par dÃ©faut si le fichier n'existe pas
        default_config = {
            "instagram_accounts": {
                "bifsteak58": {
                    "username": "bifsteak58",
                    "password": "enfoire58"
                },
                "bifsteak57": {
                    "username": "bifsteak57",
                    "password": "enfoire57"
                },
                "bifsteak56": {
                    "username": "bifsteak56",
                    "password": "enfoire56"
                }
            },
            "api_id": 30930720,
            "api_hash": "b17b4f5712c32e64e3e2772871e3589c",
            "phone": "+261341318531",
            "bot_id": "@SmmKingdomTasksBot",
            "force_relog": [],  # Par dÃ©faut comme dans ton script
            "cashcoin_values": {
                "like": 0.5,
                "follow": 1.25
            },
            "enabled_tasks": {
                "like": True,
                "follow": True
            },
            "mode": "normal"
        }
        save_config(default_config)
        return default_config
    
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"âŒ Erreur de chargement de la config: {e}")
        return None

def save_config(config):
    """Sauvegarde la configuration dans un fichier JSON"""
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        return True
    except Exception as e:
        print(f"âŒ Erreur de sauvegarde: {e}")
        return False

# ================= FICHIER DE LOGS =================
LOG_FILE = "smm_logs_second.json"

def load_logs():
    if os.path.exists(LOG_FILE):
        with open(LOG_FILE, 'r') as f:
            return json.load(f)
    return []

def save_logs(logs):
    with open(LOG_FILE, 'w') as f:
        json.dump(logs, f, indent=4)

def reset_logs():
    save_logs([])

# ================= MONITEUR STATISTIQUES =================
class TaskMonitor:
    def __init__(self):
        self.reset_all()
    
    def reset_all(self):
        """RÃ©initialise toutes les stats"""
        self.total_tasks = 0
        self.likes_attempted = 0
        self.likes_success = 0
        self.follows_attempted = 0
        self.follows_success = 0
        self.failed_tasks = 0
        self.cashcoins = 0.0
        self.current_chain = 0
        self.max_chain = 0
        self.last_account = ""
        self.account_stats = {}
    
    def reset_current_account(self, account_name):
        """RÃ©initialise les stats pour un nouveau compte"""
        if account_name not in self.account_stats:
            self.account_stats[account_name] = {
                'tasks': 0,
                'likes_attempted': 0,
                'likes_success': 0,
                'follows_attempted': 0,
                'follows_success': 0,
                'failed': 0,
                'cashcoins': 0.0,
                'chains': 0,
                'likes_count': 0,
                'follows_count': 0,
                'like_pause_until': 0,
                'follow_pause_until': 0
            }
        self.last_account = account_name
    
    def add_task(self, task_type, success=True, cashcoins=0.0):
        """Ajoute une tÃ¢che traitÃ©e"""
        self.total_tasks += 1
        
        if task_type == 'like':
            self.likes_attempted += 1
            if success:
                self.likes_success += 1
                self.cashcoins += cashcoins
                
                if self.last_account in self.account_stats:
                    self.account_stats[self.last_account]['tasks'] += 1
                    self.account_stats[self.last_account]['likes_attempted'] += 1
                    self.account_stats[self.last_account]['likes_success'] += 1
                    self.account_stats[self.last_account]['cashcoins'] += cashcoins
            else:
                self.failed_tasks += 1
                if self.last_account in self.account_stats:
                    self.account_stats[self.last_account]['failed'] += 1
        
        elif task_type == 'follow':
            self.follows_attempted += 1
            if success:
                self.follows_success += 1
                self.cashcoins += cashcoins
                
                if self.last_account in self.account_stats:
                    self.account_stats[self.last_account]['tasks'] += 1
                    self.account_stats[self.last_account]['follows_attempted'] += 1
                    self.account_stats[self.last_account]['follows_success'] += 1
                    self.account_stats[self.last_account]['cashcoins'] += cashcoins
            else:
                self.failed_tasks += 1
                if self.last_account in self.account_stats:
                    self.account_stats[self.last_account]['failed'] += 1
        
        # Gestion des chaÃ®nes
        if success:
            self.current_chain += 1
            if self.current_chain > self.max_chain:
                self.max_chain = self.current_chain
        else:
            self.current_chain = 0
    
    def get_current_stats_display(self, current_account, current_tour, total_tours=15):
        """Retourne l'affichage du moniteur"""
        likes_display = f"{self.likes_success}/{self.likes_attempted}" if self.likes_attempted > 0 else "0/0"
        follows_display = f"{self.follows_success}/{self.follows_attempted}" if self.follows_attempted > 0 else "0/0"
        
        failed_str = "ğŸš« 0"
        if self.account_stats:
            failed_accounts = [f"{acc[:8]}:{stats['failed']}" for acc, stats in self.account_stats.items() if stats.get('failed', 0) > 0]
            if failed_accounts:
                failed_str = "ğŸš« " + " ".join(failed_accounts)
                if len(failed_str) > 50:
                    failed_str = failed_str[:50] + "..."
        
        return (
            f"â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
            f"â”‚ ğŸ“Š [{current_account[:10]:10}] | Tour: {current_tour:2d}/{total_tours} | ğŸ”— {self.current_chain:1d} â”‚\n"
            f"â”‚ â¤ï¸ {likes_display:6} | ğŸ‘¥ {follows_display:6} | ğŸ’° {self.cashcoins:5.1f}cc â”‚\n"
            f"â”‚ {failed_str.ljust(56)} â”‚\n"
            f"â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        )
    
    def get_account_performance(self, account_name):
        """Retourne les performances d'un compte spÃ©cifique"""
        if account_name not in self.account_stats:
            return "Aucune donnÃ©e"
        
        stats = self.account_stats[account_name]
        total_attempted = stats['likes_attempted'] + stats['follows_attempted']
        total_success = stats['likes_success'] + stats['follows_success']
        
        if total_attempted == 0:
            return "0% (0/0)"
        
        success_rate = (total_success / total_attempted) * 100
        return f"{success_rate:.0f}% ({total_success}/{total_attempted})"

# Variables globales
current_account_index = 0
tour_count = 0
task_found = False

# Initialiser le moniteur
task_monitor = TaskMonitor()

# ================= SAFE TELEGRAM CLIENT (NOUVEAU - Anti-flood) =================
class SafeTelegramClient:
    """Wrapper autour du client Telegram avec cache et anti-flood"""
    
    def __init__(self, client):
        self.client = client
        self.cache = {}
        self.last_request_time = {}
        self.min_request_interval = 1.0  # 1 seconde minimum entre requÃªtes
        self.cache_ttl = 3.0  # Cache valide 3 secondes
    
    async def get_messages_safe(self, entity, **kwargs):
        """Version safe de get_messages avec cache et anti-flood"""
        from telethon.errors import FloodWaitError
        
        # CrÃ©er une clÃ© unique pour le cache
        cache_key = f"{entity}_{json.dumps(kwargs, sort_keys=True)}"
        current_time = time.time()
        
        # 1. VÃ©rifier le cache
        if cache_key in self.cache:
            cached_data, cache_time = self.cache[cache_key]
            if current_time - cache_time < self.cache_ttl:
                return cached_data
        
        # 2. Respecter l'intervalle minimum entre requÃªtes
        if entity in self.last_request_time:
            time_since_last = current_time - self.last_request_time[entity]
            if time_since_last < self.min_request_interval:
                await asyncio.sleep(self.min_request_interval - time_since_last)
        
        # 3. Faire la requÃªte avec catcher de flood
        retries = 3
        for attempt in range(retries):
            try:
                self.last_request_time[entity] = time.time()
                result = await self.client.get_messages(entity, **kwargs)
                
                # Mettre en cache
                self.cache[cache_key] = (result, time.time())
                return result
                
            except FloodWaitError as e:
                wait_time = e.seconds + 2  # +2 secondes de marge
                print(f"â³ FloodWait: attente {wait_time}s (tentative {attempt+1}/{retries})")
                await asyncio.sleep(wait_time)
                continue
            except Exception as e:
                print(f"âš ï¸ Erreur get_messages: {e}")
                if attempt == retries - 1:
                    return None
                await asyncio.sleep(2)
                continue
        
        return None
    
    async def send_message_safe(self, entity, message, **kwargs):
        """Version safe de send_message avec anti-flood"""
        from telethon.errors import FloodWaitError
        
        # Respecter l'intervalle minimum
        if entity in self.last_request_time:
            current_time = time.time()
            time_since_last = current_time - self.last_request_time[entity]
            if time_since_last < self.min_request_interval:
                await asyncio.sleep(self.min_request_interval - time_since_last)
        
        # Faire la requÃªte avec catcher de flood
        retries = 3
        for attempt in range(retries):
            try:
                self.last_request_time[entity] = time.time()
                result = await self.client.send_message(entity, message, **kwargs)
                return result
                
            except FloodWaitError as e:
                wait_time = e.seconds + 2
                print(f"â³ FloodWait sur send_message: attente {wait_time}s")
                await asyncio.sleep(wait_time)
                continue
            except Exception as e:
                print(f"âš ï¸ Erreur send_message: {e}")
                if attempt == retries - 1:
                    return None
                await asyncio.sleep(2)
                continue
        
        return None
    
    def clear_cache(self, entity=None):
        """Vide le cache (optionnel)"""
        if entity:
            keys_to_delete = [k for k in self.cache.keys() if str(entity) in k]
            for key in keys_to_delete:
                del self.cache[key]
        else:
            self.cache.clear()

# Variables globales pour le safe client
safe_client = None

# ================= MENU PRINCIPAL ET INTERFACE =================
def clear_screen():
    """Efface l'Ã©cran du terminal"""
    os.system('cls' if os.name == 'nt' else 'clear')

def show_main_menu():
    """Affiche le menu principal interactif"""
    while True:
        clear_screen()
        print(f"{'='*60}")
        print("ğŸ¤– SMM BOT - COMPTE SECOND - MENU PRINCIPAL".center(60))
        print(f"{'='*60}")
        print("\nğŸ“‹ Options disponibles :")
        print("  1. â–¶ï¸  Lancer le bot en mode automatique")
        print("  2. ğŸ“± GÃ©rer les comptes Instagram")
        print("  3. ğŸ”„ Forcer la reconnexion d'un compte (force_relog)")
        print("  4. ğŸ“Š Afficher les statistiques actuelles")
        print("  5. âš™ï¸  ParamÃ¨tres avancÃ©s")
        print("  6. GÃ©rer l'activation des tÃ¢ches")
        print("  7. Afficher le rapport de logs")
        print("  8. ğŸ”„ Choisir le mode de fonctionnement")
        print("  0. ğŸšª Quitter")
        print(f"{'='*60}")
        
        choix = input("\nğŸ‘‰ Votre choix [0-8] : ").strip()
        
        if choix == "1":
            return "run_bot"
        elif choix == "2":
            manage_instagram_accounts()
        elif choix == "3":
            manage_force_relog()
        elif choix == "4":
            show_current_stats()
        elif choix == "5":
            show_advanced_settings()
        elif choix == "6":
            manage_task_activations()
        elif choix == "7":
            show_log_report()
        elif choix == "8":
            manage_mode()
        elif choix == "0":
            print("\nğŸ‘‹ Au revoir !")
            exit(0)
        else:
            print("âŒ Choix invalide. Appuyez sur EntrÃ©e...")
            input()

def manage_mode():
    config = load_config()
    if not config:
        print("âŒ Impossible de charger la configuration")
        input("Appuyez sur EntrÃ©e...")
        return
    
    while True:
        clear_screen()
        print(f"{'='*60}")
        print("ğŸ”„ GESTION MODE DE FONCTIONNEMENT".center(60))
        print(f"{'='*60}")
        
        mode = config.get('mode', 'normal')
        
        print("\nğŸ“‹ Mode actuel :")
        print(f"  â€¢ {'Lente et sÃ»re' if mode == 'safe' else 'Normale'}")
        
        print("\nğŸ”§ Options :")
        print("  1. Mode lente et sÃ»re (25 likes max, 15 follows max par compte, pause 1h par action)")
        print("  2. Mode normale (sans limitation)")
        print("  0. Retour au menu principal")
        print(f"{'='*60}")
        
        choix = input("\nğŸ‘‰ Votre choix [0-2] : ").strip()
        
        if choix == "1":
            config['mode'] = 'safe'
            if save_config(config):
                print("âœ… Mode mis Ã  jour : lente et sÃ»re")
        elif choix == "2":
            config['mode'] = 'normal'
            if save_config(config):
                print("âœ… Mode mis Ã  jour : normale")
        elif choix == "0":
            return
        else:
            print("âŒ Choix invalide")
        
        input("Appuyez sur EntrÃ©e...")

def manage_task_activations():
    config = load_config()
    if not config:
        print("âŒ Impossible de charger la configuration")
        input("Appuyez sur EntrÃ©e...")
        return
    
    while True:
        clear_screen()
        print(f"{'='*60}")
        print("âš™ï¸ GESTION ACTIVATION TÃ‚CHES".center(60))
        print(f"{'='*60}")
        
        enabled = config.get('enabled_tasks', {'like': True, 'follow': True})
        
        print("\nğŸ“‹ Statut actuel :")
        print(f"  â€¢ Like : {'ActivÃ©' if enabled['like'] else 'DÃ©sactivÃ©'}")
        print(f"  â€¢ Follow : {'ActivÃ©' if enabled['follow'] else 'DÃ©sactivÃ©'}")
        
        print("\nğŸ”§ Options :")
        print("  1. Basculer Like")
        print("  2. Basculer Follow")
        print("  0. Retour au menu principal")
        print(f"{'='*60}")
        
        choix = input("\nğŸ‘‰ Votre choix [0-2] : ").strip()
        
        if choix == "1":
            enabled['like'] = not enabled['like']
            config['enabled_tasks'] = enabled
            if save_config(config):
                print("âœ… Statut mis Ã  jour")
        elif choix == "2":
            enabled['follow'] = not enabled['follow']
            config['enabled_tasks'] = enabled
            if save_config(config):
                print("âœ… Statut mis Ã  jour")
        elif choix == "0":
            return
        else:
            print("âŒ Choix invalide")
        
        input("Appuyez sur EntrÃ©e...")

def show_log_report():
    clear_screen()
    print(f"{'='*60}")
    print("ğŸ“‹ RAPPORT DE LOGS - DERNIÃˆRE SESSION".center(60))
    print(f"{'='*60}")
    
    logs = load_logs()
    if not logs:
        print("\nâœ… Aucune erreur enregistrÃ©e dans la derniÃ¨re session")
    else:
        print(f"\nğŸ“ˆ Total Ã©checs: {len(logs)}")
        
        from collections import Counter
        account_fails = Counter(log['account'] for log in logs)
        print("\nğŸ“Š Ã‰checs par compte:")
        for acc, count in account_fails.most_common():
            print(f"  â€¢ {acc}: {count}")
        
        print("\nğŸ” DÃ©tails des erreurs:")
        for log in logs:
            print(f"  [{log['timestamp']}] {log['account']} - {log['task_type'].upper()}")
            print(f"    Raison: {log['reason']}")
            if 'link' in log:
                print(f"    Lien: {log['link']}")
            print()
    
    input("\nğŸ‘ˆ Appuyez sur EntrÃ©e pour revenir...")

def manage_instagram_accounts():
    """Gestion des comptes Instagram"""
    config = load_config()
    if not config:
        print("âŒ Impossible de charger la configuration")
        input("Appuyez sur EntrÃ©e...")
        return
    
    while True:
        clear_screen()
        print(f"{'='*60}")
        print("ğŸ“± GESTION DES COMPTES INSTAGRAM".center(60))
        print(f"{'='*60}")
        
        accounts = config.get('instagram_accounts', {})
        
        if not accounts:
            print("\nâš ï¸  Aucun compte configurÃ©")
        else:
            print("\nğŸ“‹ Comptes actuellement configurÃ©s :")
            for i, (telegram_user, creds) in enumerate(accounts.items(), 1):
                print(f"  {i}. {telegram_user}")
                print(f"     ğŸ‘¤ Instagram: {creds.get('username', 'N/A')}")
                print(f"     ğŸ” Mot de passe: {'*' * len(creds.get('password', ''))}")
                print()
        
        print("\nğŸ”§ Options :")
        print("  1. Ajouter un nouveau compte")
        print("  2. Modifier un compte existant")
        print("  3. Supprimer un compte")
        print("  0. Retour au menu principal")
        print(f"{'='*60}")
        
        choix = input("\nğŸ‘‰ Votre choix [0-3] : ").strip()
        
        if choix == "1":
            add_instagram_account(config)
        elif choix == "2":
            edit_instagram_account(config)
        elif choix == "3":
            delete_instagram_account(config)
        elif choix == "0":
            if save_config(config):
                print("âœ… Configuration sauvegardÃ©e")
            input("Appuyez sur EntrÃ©e...")
            return
        else:
            print("âŒ Choix invalide")
            input("Appuyez sur EntrÃ©e...")

def manage_force_relog():
    """Gestion de l'option force_relog"""
    config = load_config()
    if not config:
        print("âŒ Impossible de charger la configuration")
        input("Appuyez sur EntrÃ©e...")
        return
    
    while True:
        clear_screen()
        print(f"{'='*60}")
        print("ğŸ”„ FORCE RELOG - RECONNEXION FORCÃ‰E".center(60))
        print(f"{'='*60}")
        
        force_relog_list = config.get('force_relog', [])
        accounts = list(config.get('instagram_accounts', {}).keys())
        
        print("\nğŸ“‹ Comptes Instagram disponibles :")
        for i, account in enumerate(accounts, 1):
            status = "âœ… FORCÃ‰" if account in force_relog_list else "âš ï¸  Normal"
            print(f"  {i}. {account} - {status}")
        
        print("\nğŸ”§ Options :")
        print("  1. Activer/dÃ©sactiver force_relog pour un compte")
        print("  2. Tout dÃ©sactiver (vider la liste)")
        print("  0. Retour au menu principal")
        print(f"{'='*60}")
        
        choix = input("\nğŸ‘‰ Votre choix [0-2] : ").strip()
        
        if choix == "1":
            print("\nğŸ‘‰ Entrez le numÃ©ro du compte Ã  modifier :")
            try:
                num = int(input("NumÃ©ro : ").strip())
                if 1 <= num <= len(accounts):
                    account = accounts[num-1]
                    if account in force_relog_list:
                        config['force_relog'].remove(account)
                        print(f"âœ… {account} retirÃ© de force_relog")
                    else:
                        if 'force_relog' not in config:
                            config['force_relog'] = []
                        config['force_relog'].append(account)
                        print(f"âœ… {account} ajoutÃ© Ã  force_relog")
                    
                    save_config(config)
                else:
                    print("âŒ NumÃ©ro invalide")
            except ValueError:
                print("âŒ Veuillez entrer un numÃ©ro valide")
        
        elif choix == "2":
            config['force_relog'] = []
            save_config(config)
            print("âœ… Liste force_relog vidÃ©e")
        
        elif choix == "0":
            return
        
        else:
            print("âŒ Choix invalide")
        
        input("\nAppuyez sur EntrÃ©e...")

def add_instagram_account(config):
    """Ajoute un nouveau compte Instagram"""
    clear_screen()
    print(f"{'='*60}")
    print("â• AJOUT D'UN NOUVEAU COMPTE".center(60))
    print(f"{'='*60}")
    
    telegram_user = input("\nğŸ‘‰ Nom du compte (pour Telegram) : ").strip()
    if not telegram_user:
        print("âŒ Nom invalide")
        input("Appuyez sur EntrÃ©e...")
        return
    
    username = input("ğŸ‘‰ Nom d'utilisateur Instagram : ").strip()
    password = input("ğŸ‘‰ Mot de passe Instagram : ").strip()
    
    if not username or not password:
        print("âŒ Identifiants invalides")
        input("Appuyez sur EntrÃ©e...")
        return
    
    if 'instagram_accounts' not in config:
        config['instagram_accounts'] = {}
    
    config['instagram_accounts'][telegram_user] = {
        'username': username,
        'password': password
    }
    
    if save_config(config):
        print(f"\nâœ… Compte {telegram_user} ajoutÃ© avec succÃ¨s !")
    
    input("Appuyez sur EntrÃ©e...")

def edit_instagram_account(config):
    """Modifie un compte Instagram existant"""
    accounts = list(config.get('instagram_accounts', {}).keys())
    
    if not accounts:
        print("âŒ Aucun compte Ã  modifier")
        input("Appuyez sur EntrÃ©e...")
        return
    
    clear_screen()
    print(f"{'='*60}")
    print("âœï¸  MODIFICATION D'UN COMPTE".center(60))
    print(f"{'='*60}")
    
    print("\nğŸ“‹ SÃ©lectionnez le compte Ã  modifier :")
    for i, account in enumerate(accounts, 1):
        print(f"  {i}. {account}")
    
    try:
        num = int(input("\nğŸ‘‰ NumÃ©ro du compte : ").strip())
        if 1 <= num <= len(accounts):
            account = accounts[num-1]
            creds = config['instagram_accounts'][account]
            
            print(f"\nğŸ“ Modification de {account}")
            print(f"   Ancien username: {creds['username']}")
            print(f"   Ancien password: {'*' * len(creds['password'])}")
            print("\n   Laissez vide pour ne pas modifier")
            
            new_username = input("   ğŸ‘‰ Nouveau username : ").strip()
            new_password = input("   ğŸ‘‰ Nouveau password : ").strip()
            
            if new_username:
                creds['username'] = new_username
            if new_password:
                creds['password'] = new_password
            
            if save_config(config):
                print(f"\nâœ… Compte {account} modifiÃ© avec succÃ¨s !")
        else:
            print("âŒ NumÃ©ro invalide")
    except ValueError:
        print("âŒ Veuillez entrer un numÃ©ro valide")
    
    input("Appuyez sur EntrÃ©e...")

def delete_instagram_account(config):
    """Supprime un compte Instagram"""
    accounts = list(config.get('instagram_accounts', {}).keys())
    
    if not accounts:
        print("âŒ Aucun compte Ã  supprimer")
        input("Appuyez sur EntrÃ©e...")
        return
    
    clear_screen()
    print(f"{'='*60}")
    print("ğŸ—‘ï¸  SUPPRESSION D'UN COMPTE".center(60))
    print(f"{'='*60}")
    
    print("\nğŸ“‹ SÃ©lectionnez le compte Ã  supprimer :")
    for i, account in enumerate(accounts, 1):
        print(f"  {i}. {account}")
    
    try:
        num = int(input("\nğŸ‘‰ NumÃ©ro du compte : ").strip())
        if 1 <= num <= len(accounts):
            account = accounts[num-1]
            
            confirm = input(f"\nâš ï¸  ÃŠtes-vous sÃ»r de vouloir supprimer {account} ? (o/N) : ").strip().lower()
            if confirm == 'o' or confirm == 'oui':
                del config['instagram_accounts'][account]
                
                # Retirer aussi de force_relog si prÃ©sent
                if account in config.get('force_relog', []):
                    config['force_relog'].remove(account)
                
                if save_config(config):
                    print(f"âœ… Compte {account} supprimÃ© avec succÃ¨s !")
            else:
                print("âŒ Suppression annulÃ©e")
        else:
            print("âŒ NumÃ©ro invalide")
    except ValueError:
        print("âŒ Veuillez entrer un numÃ©ro valide")
    
    input("Appuyez sur EntrÃ©e...")

def show_current_stats():
    """Affiche les statistiques actuelles"""
    clear_screen()
    print(f"{'='*60}")
    print("ğŸ“Š STATISTIQUES ACTUELLES".center(60))
    print(f"{'='*60}")
    
    print(f"\nğŸ“ˆ Performances globales :")
    print(f"  â€¢ TÃ¢ches totales : {task_monitor.total_tasks}")
    print(f"  â€¢ Likes : {task_monitor.likes_success}/{task_monitor.likes_attempted}")
    print(f"  â€¢ Follows : {task_monitor.follows_success}/{task_monitor.follows_attempted}")
    print(f"  â€¢ CashCoins : {task_monitor.cashcoins:.2f}cc")
    print(f"  â€¢ ChaÃ®ne max : {task_monitor.max_chain}")
    
    print(f"\nğŸ’° Valeurs CashCoins configurÃ©es :")
    config = load_config()
    if config and 'cashcoin_values' in config:
        values = config['cashcoin_values']
        print(f"  â€¢ Like : {values.get('like', 0.5)}cc")
        print(f"  â€¢ Follow : {values.get('follow', 1.25)}cc")
    
    input("\nğŸ‘ˆ Appuyez sur EntrÃ©e pour revenir...")

def show_advanced_settings():
    """Affiche les paramÃ¨tres avancÃ©s"""
    clear_screen()
    print(f"{'='*60}")
    print("âš™ï¸  PARAMÃˆTRES AVANCÃ‰S".center(60))
    print(f"{'='*60}")
    
    config = load_config()
    if not config:
        print("âŒ Impossible de charger la configuration")
        input("Appuyez sur EntrÃ©e...")
        return
    
    print(f"\nğŸ“± Configuration actuelle :")
    print(f"  â€¢ API ID : {config.get('api_id', 'N/A')}")
    print(f"  â€¢ TÃ©lÃ©phone : {config.get('phone', 'N/A')}")
    print(f"  â€¢ Bot ID : {config.get('bot_id', '@SmmKingdomTasksBot')}")
    print(f"  â€¢ Force Relog actif : {len(config.get('force_relog', []))} compte(s)")
    
    print(f"\nğŸ”§ Options :")
    print("  1. Modifier les identifiants Telegram")
    print("  2. Modifier les valeurs CashCoins")
    print("  0. Retour")
    
    choix = input("\nğŸ‘‰ Votre choix [0-2] : ").strip()
    
    if choix == "1":
        clear_screen()
        print(f"{'='*60}")
        print("ğŸ” MODIFICATION TELEGRAM".center(60))
        print(f"{'='*60}")
        
        print(f"\nğŸ“ Valeurs actuelles :")
        print(f"  API ID : {config.get('api_id', '')}")
        print(f"  API Hash : {config.get('api_hash', '')}")
        print(f"  TÃ©lÃ©phone : {config.get('phone', '')}")
        print(f"  Bot ID : {config.get('bot_id', '')}")
        
        print("\n   Laissez vide pour ne pas modifier")
        
        new_api_id = input("   ğŸ‘‰ Nouvel API ID : ").strip()
        new_api_hash = input("   ğŸ‘‰ Nouvel API Hash : ").strip()
        new_phone = input("   ğŸ‘‰ Nouveau tÃ©lÃ©phone : ").strip()
        new_bot_id = input("   ğŸ‘‰ Nouveau Bot ID : ").strip()
        
        if new_api_id:
            config['api_id'] = int(new_api_id)
        if new_api_hash:
            config['api_hash'] = new_api_hash
        if new_phone:
            config['phone'] = new_phone
        if new_bot_id:
            config['bot_id'] = new_bot_id
        
        if save_config(config):
            print("\nâœ… Configuration Telegram mise Ã  jour !")
    
    elif choix == "2":
        clear_screen()
        print(f"{'='*60}")
        print("ğŸ’° VALEURS CASHCOINS".center(60))
        print(f"{'='*60}")
        
        if 'cashcoin_values' not in config:
            config['cashcoin_values'] = {'like': 0.5, 'follow': 1.25}
        
        values = config['cashcoin_values']
        print(f"\nğŸ’° Valeurs actuelles :")
        print(f"  â€¢ Like : {values.get('like', 0.5)}cc")
        print(f"  â€¢ Follow : {values.get('follow', 1.25)}cc")
        
        print("\n   Entrez les nouvelles valeurs :")
        try:
            new_like = input(f"   ğŸ‘‰ Valeur pour Like [{values.get('like', 0.5)}] : ").strip()
            new_follow = input(f"   ğŸ‘‰ Valeur pour Follow [{values.get('follow', 1.25)}] : ").strip()
            
            if new_like:
                config['cashcoin_values']['like'] = float(new_like)
            if new_follow:
                config['cashcoin_values']['follow'] = float(new_follow)
            
            if save_config(config):
                print("\nâœ… Valeurs CashCoins mises Ã  jour !")
        except ValueError:
            print("âŒ Veuillez entrer des nombres valides")
    
    elif choix == "0":
        return
    
    else:
        print("âŒ Choix invalide")
    
    input("\nAppuyez sur EntrÃ©e...")

def display_monitor(current_account, current_tour):
    """Affiche le moniteur en haut de l'Ã©cran"""
    print("\033[2J\033[H")  # Clear screen and move cursor to top
    print(task_monitor.get_current_stats_display(current_account, current_tour))
    print()

# ================= INSTAGRAM AUTOMATOR =================
class InstagramAutomator:
    def __init__(self, accounts_config, force_relog_list):
        self.clients = {}
        self.setup_logging()
        self.init_clients(accounts_config, force_relog_list)
    
    def setup_logging(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def init_clients(self, accounts_config, force_relog_list):
        """Initialise les clients Instagram avec gestion de force_relog"""
        self.logger.info("ğŸ”§ Initialisation Instagram...")
        
        for telegram_user, creds in accounts_config.items():
            try:
                client = Client()
                client.delay_range = [2, 5]
                
                # âš ï¸ IMPORTANT : J'utilise le mÃªme nom de session que ton script original
                session_file = f"session_{telegram_user}.json"
                
                # VÃ©rifier si force_relog est activÃ© pour ce compte
                if telegram_user in force_relog_list:
                    print(f"âš ï¸ FORCE RELOG activÃ© pour {telegram_user}")
                    if os.path.exists(session_file):
                        print(f"   ğŸ—‘ï¸ Suppression de l'ancienne session...")
                        try:
                            os.remove(session_file)
                        except Exception as e:
                            print(f"   âš ï¸ Erreur suppression: {e}")

                try:
                    if os.path.exists(session_file):
                        client.load_settings(session_file)
                        client.login(creds['username'], creds['password'])
                        print(f"âœ… Session chargÃ©e pour {telegram_user}")
                    else:
                        print(f"ğŸ”„ Nouvelle connexion pour {telegram_user}")
                        client.login(creds['username'], creds['password'])
                        
                    client.dump_settings(session_file)
                    print(f"ğŸ’¾ Session sauvegardÃ©e pour {telegram_user}")
                    
                    user_id = client.user_id
                    self.clients[telegram_user] = client
                    print(f"âœ… {telegram_user} prÃªt (ID: {user_id})")
                    
                except (ClientLoginRequired, ClientError) as e:
                    reason = str(e)
                    print(f"âŒ Erreur connexion {telegram_user}: {reason[:100]}")
                    autor = input(f"Autoriser la poursuite du script malgrÃ© l'Ã©chec pour {telegram_user}? (o/n): ").strip().lower()
                    if autor != 'o':
                        sys.exit(1)
                    continue
                    
            except Exception as e:
                reason = str(e)
                print(f"âŒ Erreur init {telegram_user}: {reason}")
                autor = input(f"Autoriser la poursuite du script malgrÃ© l'Ã©chec pour {telegram_user}? (o/n): ").strip().lower()
                if autor != 'o':
                    sys.exit(1)
    
    def is_real_task(self, message):
        """VÃ©rifie si c'est une VRAIE tÃ¢che (pas un Thank you)"""
        if not message:
            return False
        
        message_lower = message.lower()
        
        if message_lower.startswith("thank you"):
            return False
        
        has_link_marker = "â–ªï¸ link :" in message_lower
        has_action_marker = "â–ªï¸ action :" in message_lower
        has_task_action = any(phrase in message_lower for phrase in ["follow the profile", "like the post below"])
        
        return has_link_marker and has_action_marker and has_task_action
    
    def extract_task_info(self, message):
        """Extrait les infos d'une VRAIE tÃ¢che"""
        try:
            lines = message.split('\n')
            task_info = {'type': None, 'link': None}
            
            for i, line in enumerate(lines):
                line = line.strip()
                
                if 'â–ªï¸ link :' in line.lower() and i+1 < len(lines):
                    link = lines[i+1].strip()
                    if link.startswith('http'):
                        task_info['link'] = link
                
                elif 'â–ªï¸ action :' in line.lower() and i+1 < len(lines):
                    action_line = lines[i+1].strip().lower()
                    if 'follow' in action_line:
                        task_info['type'] = 'follow'
                    elif 'like' in action_line:
                        task_info['type'] = 'like'
            
            if task_info['type'] and task_info['link']:
                return task_info
            return None
            
        except Exception as e:
            print(f"âŒ Erreur extraction tÃ¢che: {e}")
            return None
    
    async def execute_task(self, telegram_user, task_type, target_link):
        """ExÃ©cute la tÃ¢che avec le bon compte"""
        if telegram_user not in self.clients:
            print(f"âŒ Compte {telegram_user} non initialisÃ©")
            return False, "Compte non initialisÃ©"
        
        client = self.clients[telegram_user]
        
        success, message = await self._attempt_task(client, task_type, target_link, 1)
        
        if not success:
            print("ğŸ”„ DeuxiÃ¨me tentative...")
            await asyncio.sleep(random.uniform(2, 4))
            success, message = await self._attempt_task(client, task_type, target_link, 2)
        
        return success, message
    
    async def _attempt_task(self, client, task_type, target, attempt_num):
        try:
            if task_type == 'like':
                media_pk = client.media_pk_from_url(target)
                await asyncio.sleep(random.uniform(1, 2))
                result = client.media_like(media_pk)
                await asyncio.sleep(random.uniform(1, 2))
                
                if result:
                    return True, "Like rÃ©ussi"
                else:
                    try:
                        media_info = client.media_info(media_pk)
                        if hasattr(media_info, 'viewer_has_liked') and media_info.viewer_has_liked:
                            return True, "Like vÃ©rifiÃ©"
                    except:
                        pass
                    return False, "Like non confirmÃ©"
            
            elif task_type == 'follow':
                if target.endswith('/'):
                    target = target[:-1]
                username = target.split('/')[-1]
                user_id = client.user_id_from_username(username)
                
                await asyncio.sleep(random.uniform(1, 2))
                result = client.user_follow(user_id)
                await asyncio.sleep(random.uniform(1, 2))
                
                if result:
                    return True, "Follow rÃ©ussi"
                else:
                    return False, "Follow non confirmÃ©"
            
            return False, "Type inconnu"
                
        except Exception as e:
            return False, f"Erreur: {str(e)[:50]}"

# ================= NOTIFICATIONS TERMUX =================
async def notify_termux(title, content):
    try:
        os.system(f'termux-notification --title "{title}" --content "{content}" --sound')
        os.system('termux-vibrate -d 300')
        print(f"ğŸ”” {title}: {content}")
        return True
    except:
        return False

# ================= GESTION COMPTES =================
def get_next_account(accounts_list):
    """GÃ¨re la rotation des comptes Instagram"""
    global current_account_index, tour_count
    
    if not accounts_list:
        return None
    
    tour_count += 1
    current_account = accounts_list[current_account_index]
    
    # Afficher le moniteur avant chaque tour
    display_monitor(current_account, tour_count)
    
    # RÃ©initialiser les stats pour le nouveau compte si c'est le dÃ©but
    if tour_count == 1:
        task_monitor.reset_current_account(current_account)
    
    if tour_count >= 15:
        # Afficher mini-rÃ©sumÃ© avant rotation
        old_account = accounts_list[current_account_index]
        performance = task_monitor.get_account_performance(old_account)
        print(f"\nğŸ”„ Rotation: {old_account} â†’ ", end="")
        
        current_account_index = (current_account_index + 1) % len(accounts_list)
        tour_count = 0
        new_account = accounts_list[current_account_index]
        
        print(f"{new_account} | Performances: {performance}")
        
        # RÃ©initialiser pour le nouveau compte
        task_monitor.reset_current_account(new_account)
        display_monitor(new_account, tour_count)
        
        return new_account
    
    return current_account

# ================= FONCTIONS TELEGRAM SAFE (MODIFIÃ‰ES) =================
async def click_button(client, bot_id, text_to_find):
    """Cherche et clique sur un bouton - Version safe amÃ©liorÃ©e"""
    global safe_client
    
    try:
        # Utiliser get_messages_safe avec plus de messages pour Ãªtre sÃ»r
        messages = await safe_client.get_messages_safe(bot_id, limit=10)  # AugmentÃ© de 5 Ã  10
        if not messages:
            print(f"âŒ Aucun message trouvÃ© pour {bot_id}")
            return False
        
        print(f"ğŸ” Recherche du bouton '{text_to_find}' dans {len(messages)} messages...")
        
        for message in messages:
            if message.buttons:
                for row in message.buttons:
                    for btn in row:
                        if text_to_find.lower() in btn.text.lower():
                            print(f"âœ… Bouton trouvÃ© : '{btn.text}'")
                            await asyncio.sleep(0.5)
                            await btn.click()
                            print(f"âœ… Clic effectuÃ©.")
                            return True
        
        print(f"âŒ Bouton contenant '{text_to_find}' non trouvÃ© dans les {len(messages)} derniers messages.")
        return False
        
    except Exception as e:
        print(f"âš ï¸ Erreur dans click_button: {e}")
        return False

async def get_bot_response(client, bot_id):
    """Lit la DERNIÃˆRE rÃ©ponse du bot - Version safe avec cache intelligent"""
    global safe_client
    
    try:
        # Utiliser la version safe
        messages = await safe_client.get_messages_safe(bot_id, limit=2)
        
        if messages and len(messages) > 0:
            return messages[0].message
        else:
            # Si aucun message n'est trouvÃ©, on vide le cache pour forcer un rafraÃ®chissement
            # Cela casse les boucles infinies oÃ¹ le cache retourne toujours None
            print("ğŸ“­ Aucun message trouvÃ©, vidage du cache...")
            safe_client.clear_cache(bot_id)
            return None
    except Exception as e:
        print(f"âš ï¸ Erreur lecture message: {e}")
        return None

async def wait_for_sorry(client, bot_id):
    """Attend UNIQUEMENT le mot 'Sorry' (ignore tout le reste)"""
    print("ğŸ•— En attente du 'Sorry'...")
    
    # D'abord vÃ©rifier avec cache
    current_msg = await get_bot_response(client, bot_id)
    if current_msg and "sorry" in current_msg.lower():
        print("âœ… 'Sorry' dÃ©jÃ  prÃ©sent")
        return True
    
    event_received = asyncio.Event()
    
    @client.on(events.NewMessage(from_users=bot_id))
    async def handler(event):
        if "sorry" in event.raw_text.lower():
            print("âœ… 'Sorry' reÃ§u")
            event_received.set()
        else:
            print(f"ğŸ“„ Message ignorÃ©: {event.raw_text[:50]}...")
    
    try:
        await asyncio.wait_for(event_received.wait(), timeout=180)
        client.remove_event_handler(handler)
        return True
    except asyncio.TimeoutError:
        print("âš ï¸  Timeout attente Sorry")
        client.remove_event_handler(handler)
        return False

# ================= GESTION TÃ‚CHES SIMPLE =================
async def process_task(client, instagram_automator, task_message, telegram_user, bot_id, cashcoin_values, config):
    """Traite une tÃ¢che Instagram"""
    
    task_info = instagram_automator.extract_task_info(task_message)
    
    if not task_info:
        print("âŒ Impossible d'extraire les infos")
        await notify_termux("SMM - ERREUR", "Analyse tÃ¢che impossible")
        return False
    
    enabled_tasks = config.get('enabled_tasks', {'like': True, 'follow': True})
    if not enabled_tasks.get(task_info['type'], True):
        print(f"âš ï¸ TÃ¢che {task_info['type']} dÃ©sactivÃ©e - Skip automatique")
        await safe_client.send_message_safe(bot_id, "âŒSkip")
        print("ğŸ“¤ EnvoyÃ©: âŒSkip")
        return False
    
    mode = config.get('mode', 'normal')
    if mode == 'safe':
        now = time.time()
        stats = task_monitor.account_stats[telegram_user]
        pause_key = f"{task_info['type']}_pause_until"
        count_key = f"{task_info['type']}s_count"
        max_count = 25 if task_info['type'] == 'like' else 15

        if stats.get(pause_key, 0) > now:
            print(f"â¸ï¸ Pause active pour {task_info['type']} jusqu'Ã  {datetime.fromtimestamp(stats[pause_key])}")
            await safe_client.send_message_safe(bot_id, "âŒSkip")
            print("ğŸ“¤ EnvoyÃ©: âŒSkip (pause active)")
            return False

        if stats.get(pause_key, 0) > 0:
            stats[count_key] = 0
            stats[pause_key] = 0

        if stats.get(count_key, 0) >= max_count:
            stats[pause_key] = now + 3600
            print(f"ğŸš« Limite atteinte pour {task_info['type']}, pause 1h")
            await safe_client.send_message_safe(bot_id, "âŒSkip")
            print("ğŸ“¤ EnvoyÃ©: âŒSkip (limite atteinte)")
            return False
    
    print(f"ğŸ“‹ Type: {task_info['type'].upper()}")
    print(f"ğŸ”— Lien: {task_info['link']}")
    print(f"ğŸ‘¤ Compte: {telegram_user}")
    
    print("ğŸ”„ ExÃ©cution...")
    success, result = await instagram_automator.execute_task(telegram_user, task_info['type'], task_info['link'])
    
    # Valeurs CashCoins depuis la config
    cashcoins = cashcoin_values.get(task_info['type'], 0.5 if task_info['type'] == 'like' else 1.25)
    
    if success:
        print(f"âœ… TÃ¢che {task_info['type'].upper()} rÃ©ussie!", end=" ")
        
        # Ajouter aux stats
        task_monitor.add_task(task_info['type'], True, cashcoins)
        
        # RafraÃ®chir l'affichage
        display_monitor(telegram_user, tour_count)
        
        # Afficher mise Ã  jour
        likes_display = f"{task_monitor.likes_success}/{task_monitor.likes_attempted}"
        follows_display = f"{task_monitor.follows_success}/{task_monitor.follows_attempted}"
        print(f"(+{cashcoins}cc) [â¤ï¸{likes_display} ğŸ‘¥{follows_display} ğŸ’°{task_monitor.cashcoins:.1f}cc]")
        
        if mode == 'safe':
            stats[count_key] += 1
            if stats[count_key] >= max_count:
                stats[pause_key] = now + 3600
                print(f"â° Pause activÃ©e pour {task_info['type']} pendant 1h")
        
        # Envoyer âœ…Completed avec version safe
        await asyncio.sleep(1)
        await safe_client.send_message_safe(bot_id, "âœ…Completed")
        print("ğŸ“¤ EnvoyÃ©: âœ…Completed")
        
        # VÃ©rifier la rÃ©ponse du bot avec cache
        print("ğŸ”„ VÃ©rification rÃ©ponse bot...")
        await asyncio.sleep(2)
        
        bot_response = await get_bot_response(client, bot_id)
        
        if bot_response:
            # VÃ©rifier si c'est une NOUVELLE tÃ¢che
            if instagram_automator.is_real_task(bot_response):
                print("\nğŸ”„ NOUVELLE TÃ‚CHE DÃ‰TECTÃ‰E!")
                print("ğŸ¤– Traitement en chaÃ®ne...")
                
                return await process_task(client, instagram_automator, bot_response, telegram_user, bot_id, cashcoin_values, config)
            
            # VÃ©rifier si c'est "Sorry"
            elif "sorry" in bot_response.lower():
                print("âœ… 'Sorry' reÃ§u. Fin de traitement.")
                return True
            
            # Sinon, attendre le Sorry
            else:
                print(f"ğŸ“„ Message reÃ§u: {bot_response[:50]}...")
                print("ğŸ•— Attente du 'Sorry'...")
                await wait_for_sorry(client, bot_id)
                return True
        else:
            # Pas de rÃ©ponse, attendre le Sorry
            print("â³ Pas de rÃ©ponse, attente du 'Sorry'...")
            await wait_for_sorry(client, bot_id)
            return True
    
    else:
        # Ã‰CHEC de la tÃ¢che
        print(f"âŒ Ã‰chec: {result}", end=" ")
        
        # Ajouter aux stats (Ã©chec)
        task_monitor.add_task(task_info['type'], False, 0)
        
        # RafraÃ®chir l'affichage
        display_monitor(telegram_user, tour_count)
        
        likes_display = f"{task_monitor.likes_success}/{task_monitor.likes_attempted}"
        follows_display = f"{task_monitor.follows_success}/{task_monitor.follows_attempted}"
        print(f"[â¤ï¸{likes_display} ğŸ‘¥{follows_display} ğŸ’°{task_monitor.cashcoins:.1f}cc]")
        
        logs = load_logs()
        logs.append({
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'account': telegram_user,
            'task_type': task_info['type'],
            'reason': result,
            'link': task_info['link']
        })
        save_logs(logs)
        
        await safe_client.send_message_safe(bot_id, "âŒSkip")
        print("ğŸ“¤ EnvoyÃ©: âŒSkip")
        return False

# ================= BOUCLE PRINCIPALE SIMPLE =================
async def main_bot():
    """Fonction principale du bot (exÃ©cutÃ©e quand on choisit "Lancer le bot")"""
    global task_found, current_account_index, tour_count, safe_client
    
    # Charger la configuration
    config = load_config()
    if not config:
        print("âŒ Impossible de charger la configuration")
        return
    
    reset_logs()
    
    # Initialiser les variables depuis la config
    api_id = config.get('api_id', 30930720)
    api_hash = config.get('api_hash', "b17b4f5712c32e64e3e2772871e3589c")
    phone = config.get('phone', "+261341318531")
    bot_id = config.get('bot_id', "@SmmKingdomTasksBot")
    instagram_accounts = config.get('instagram_accounts', {})
    force_relog = config.get('force_relog', ["bifsteak56"])
    cashcoin_values = config.get('cashcoin_values', {'like': 0.5, 'follow': 1.25})
    
    if not instagram_accounts:
        print("âŒ Aucun compte Instagram configurÃ©")
        input("Appuyez sur EntrÃ©e pour revenir...")
        return
    
    # RÃ©initialiser les variables globales
    current_account_index = 0
    tour_count = 0
    task_found = False
    
    # âš ï¸ IMPORTANT : Je garde le mÃªme nom de session que ton script original
    session_name = "smm_session"
    
    print(f"\nğŸ“ Session Telegram: {session_name}")
    print(f"ğŸ“± NumÃ©ro: {phone}")
    print(f"ğŸ¤– Bot: {bot_id}")
    print(f"ğŸ“Š {len(instagram_accounts)} compte(s) Instagram configurÃ©(s)")
    print(f"ğŸ”„ Force Relog: {len(force_relog)} compte(s)")
    
    # Initialiser le client Telegram (SANS modification du nom de session)
    client = TelegramClient(session_name, api_id, api_hash)
    
    # Initialiser le safe client (NOUVEAU)
    safe_client = SafeTelegramClient(client)
    print("ğŸ”’ SafeTelegramClient initialisÃ© (anti-flood activÃ©)")
    
    # Initialiser l'automateur Instagram
    instagram_automator = InstagramAutomator(instagram_accounts, force_relog)
    
    await notify_termux("SMM BOT", "DÃ©marrage du bot...")
    
    current_state = "debut"
    target_accounts = list(instagram_accounts.keys())
    
    while True:
        try:
            # === Ã‰TAT 1: DÃ‰BUT / RECONNEXION ===
            if current_state == "debut" or not client.is_connected():
                print("\nğŸ”— Connexion Telegram...")
                
                # Connexion simple sans force_sms
                await client.start(phone=phone)
                
                print(f"âœ… CONNECTÃ‰: {phone}")
                
                print("ğŸš€ /start au bot...")
                await safe_client.send_message_safe(bot_id, "/start")
                await asyncio.sleep(1.5)
                current_state = "menu_principal"
            
            # === Ã‰TAT 2: MENU PRINCIPAL (aprÃ¨s /start) ===
            if current_state == "menu_principal":
                print("\nğŸ“ Clic sur 'ğŸ“TasksğŸ“'...")
                if await click_button(client, bot_id, "ğŸ“TasksğŸ“"):
                    await asyncio.sleep(1)
                    current_state = "menu_tasks"
                else:
                    print("âŒ Ã‰chec Tasks. Retour /start...")
                    await safe_client.send_message_safe(bot_id, "/start")
                    await asyncio.sleep(2)
                    continue
            
            # === Ã‰TAT 3: MENU TASKS ===
            if current_state == "menu_tasks":
                print("\nğŸ“¸ Clic sur 'Instagram'...")
                if await click_button(client, bot_id, "Instagram"):
                    await asyncio.sleep(1)
                    current_state = "menu_instagram"
                else:
                    print("âŒ Ã‰chec Instagram. Retour /start...")
                    await safe_client.send_message_safe(bot_id, "/start")
                    await asyncio.sleep(2)
                    current_state = "menu_principal"
                    continue
            
            # === Ã‰TAT 4: MENU INSTAGRAM (choix du compte) ===
            if current_state == "menu_instagram":
                current_target = get_next_account(target_accounts)
                
                if not current_target:
                    print("âŒ Erreur: aucune cible disponible")
                    current_state = "menu_tasks"
                    continue
                
                print(f"\n{'â”€'*30}")
                print(f"ğŸ“± Compte: {current_target}")
                print(f"{'â”€'*30}")
                
                # ğŸ”¥ MODIFICATION CRITIQUE : Vidage du cache avant de chercher le bouton
                # C'est le moment oÃ¹ le script bloque le plus souvent
                safe_client.clear_cache(bot_id)
                print("ğŸ§¹ Cache vidÃ© pour rafraÃ®chir les messages...")
                
                print(f"â¡ï¸ Clic sur {current_target}...")
                if await click_button(client, bot_id, current_target):
                    await asyncio.sleep(1)
                    current_state = "verif_tache"
                else:
                    print("âŒ Ã‰chec sÃ©lection compte. Retour menu Instagram...")
                    current_state = "menu_instagram"
                    continue
            
            # === Ã‰TAT 5: VÃ‰RIFICATION TÃ‚CHE ===
            if current_state == "verif_tache":
                print("\nğŸ” VÃ©rification message bot...")
                
                bot_response = await get_bot_response(client, bot_id)
                
                if not bot_response:
                    print("âŒ Pas de rÃ©ponse du bot. Retour menu Instagram...")
                    current_state = "menu_tasks"
                    continue
                
                bot_response_lower = bot_response.lower()
                
                if "sorry" in bot_response_lower or "no active tasks" in bot_response_lower:
                    print("â›” Pas de tÃ¢che disponible")
                    current_state = "menu_tasks"
                    continue
                
                if bot_response_lower.startswith("thank you"):
                    print("â›” Message 'Thank you' ignorÃ©")
                    current_state = "menu_tasks"
                    continue
                
                if instagram_automator.is_real_task(bot_response):
                    print("\n" + "="*50)
                    print("ğŸ¯ TÃ‚CHE DÃ‰TECTÃ‰E !")
                    print("="*50)
                    
                    task_found = True
                    
                    task_success = await process_task(client, instagram_automator, bot_response, current_target, bot_id, cashcoin_values, config)
                    
                    print("\nğŸ”„ Retour au menu Instagram...")
                    task_found = False
                    current_state = "menu_tasks"
                    await asyncio.sleep(1)
                    continue
                
                print(f"ğŸ“„ Message inattendu: {bot_response[:50]}...")
                print("ğŸ”„ Retour au menu Instagram...")
                current_state = "menu_tasks"
                continue
            
            await asyncio.sleep(0.5)
            
        except Exception as e:
            print(f"\nâŒ ERREUR: {e}")
            import traceback
            traceback.print_exc()
            print("ğŸ”„ Reconnexion dans 10s...")
            
            try:
                await client.disconnect()
            except:
                pass
            
            await asyncio.sleep(10)
            current_state = "debut"

# ================= POINT D'ENTRÃ‰E PRINCIPAL =================
async def main():
    """Point d'entrÃ©e principal avec menu interactif"""
    
    # Afficher le menu principal
    choix = show_main_menu()
    
    if choix == "run_bot":
        # Lancer le bot
        await main_bot()
        
        # Quand le bot s'arrÃªte (erreur ou Ctrl+C)
        print("\n" + "="*50)
        print("ğŸ“Š STATISTIQUES DE LA SESSION :")
        print("="*50)
        print(f"â”œâ”€ TÃ¢ches totales: {task_monitor.total_tasks}")
        print(f"â”œâ”€ Likes: {task_monitor.likes_success}/{task_monitor.likes_attempted}")
        print(f"â”œâ”€ Follows: {task_monitor.follows_success}/{task_monitor.follows_attempted}")
        print(f"â”œâ”€ CashCoins totaux: {task_monitor.cashcoins:.2f}")
        print(f"â”œâ”€ ChaÃ®ne max: {task_monitor.max_chain}")
        print(f"â””â”€ Taux rÃ©ussite: ", end="")
        
        total_attempted = task_monitor.likes_attempted + task_monitor.follows_attempted
        total_success = task_monitor.likes_success + task_monitor.follows_success
        if total_attempted > 0:
            print(f"{(total_success/total_attempted)*100:.1f}%")
        else:
            print("0%")
        
        input("\nğŸ‘ˆ Appuyez sur EntrÃ©e pour revenir au menu...")
        
        # Retour au menu principal
        await main()

# ================= LANCEMENT =================
if __name__ == "__main__":
    print("ğŸ¤– SMM BOT - COMPTE SECOND - VERSION AMÃ‰LIORÃ‰E")
    print("ğŸ“Š Interface interactive avec moniteur et gestion des comptes")
    print("ğŸ’° Like: 0.5cc | Follow: 1.25cc")
    print("ğŸ”„ Force Relog disponible via menu")
    print("ğŸ”’ SystÃ¨me anti-flood activÃ©")
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ ArrÃªt du programme.")
    except Exception as e:
        print(f"\nğŸ’¥ Erreur fatale: {e}")
        import traceback
        traceback.print_exc()
        input("\nAppuyez sur EntrÃ©e pour quitter...")
